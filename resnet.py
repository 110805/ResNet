# -*- coding: utf-8 -*-
"""ResNet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/110805/Retinopathy_detection/blob/master/ResNet.ipynb
"""


from dataloader import RetinopathyLoader
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import DataLoader
import torchvision.models
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import copy

# Hyperparameter setting
batch_size = 4
learning_rate = 1e-3
epochs_18 = 10
epochs_50 = 5
momentum = 0.9
weight_decay = 5e-4
criterion = nn.CrossEntropyLoss()

train_data = RetinopathyLoader(root='/home/ubuntu/Retinopathy_detection/data/', mode='train')
test_data = RetinopathyLoader(root='/home/ubuntu/Retinopathy_detection/data/', mode='test')
train_loader = DataLoader(train_data, batch_size=batch_size)
test_loader = DataLoader(test_data, batch_size=batch_size)

ResNet18_1 = torchvision.models.resnet18(pretrained=False)
ResNet18_1.fc = nn.Linear(512, 5)
ResNet18_2 = torchvision.models.resnet18(pretrained=True)
ResNet18_2.fc = nn.Linear(512, 5)
ResNet50_1 = torchvision.models.resnet50(pretrained=False)
ResNet50_1.fc = nn.Linear(2048, 5)
ResNet50_2 = torchvision.models.resnet50(pretrained=True)
ResNet50_2.fc = nn.Linear(2048, 5)

#models = [ResNet50_1, ResNet50_2]
models = [ResNet18_2, ResNet18_1, ResNet50_1, ResNet50_2]
device = torch.device('cuda')

def train(model):
    model.train()
    correct = 0

    for idx, (inputs, labels) in enumerate(train_loader):
        inputs = inputs.to(device)
        labels = labels.to(device)
        optimizer.zero_grad()
        outputs = model(inputs.float())
        loss = criterion(outputs, labels.flatten())
        _, preds = torch.max(outputs, 1) # the second return of max is the return of argmax
        loss.backward()
        optimizer.step()
        correct += torch.sum(preds == labels.data.flatten())
            
    epoch_acc = 100*correct.item() / 28099    
    print('Train Acc: {:2f}%'.format(epoch_acc))

    return epoch_acc

def test(model, best_acc, best_model_weight):
    model.eval()
    correct = 0

    for idx, (inputs, labels) in enumerate(test_loader):
        inputs = inputs.to(device)
        labels = labels.to(device)
        with torch.no_grad():
            outputs = model(inputs.float())

        _, preds = torch.max(outputs, 1) # the second return of max is the return of argmax
        correct += torch.sum(preds == labels.data.flatten())
            
    epoch_acc = 100*correct.item() / 7025    
    print('Test Acc: {:2f}%'.format(epoch_acc))

    if epoch_acc > best_acc:
        best_model_weight = copy.deepcopy(model.state_dict())

    return epoch_acc, best_model_weight

model_weight = []
legend = ['Train(w/o pretrain)', 'Test(w/o pretrain)', 'Train(with pretrain)', 'Test(with pretrain)']
for i, model in enumerate(models):
    best_acc = 0
    model.to(device)
    train_acc = []
    test_acc = []
    optimizer = optim.SGD(model.parameters(), lr=learning_rate, momentum=momentum, weight_decay=weight_decay)
    weight = copy.deepcopy(model.state_dict())

    if i == 0:
        epochs = epochs_18
        plt.figure(1)
    if i == 2:
        epochs = epochs_50
        plt.figure(2)

    for epoch in range(3):
        print('Epoch {}'.format(epoch+1))
        train_acc.append(train(model))
        acc, weight = test(model, best_acc, weight)
        test_acc.append(acc)
        if acc > best_acc:
            best_acc = acc

        print('-' * 10)
    
    torch.save(weight, '{}.pkl'.format(1))
    '''
    model_weight.append(weight)
    print('Best Acc: {:2f}%'.format(best_acc))
    if i < 2:
        plt.plot(range(epochs), train_acc, label=legend[2*i])
        plt.plot(range(epochs), test_acc, label=legend[2*i+1])
    else:
        plt.plot(range(epochs), train_acc, label=legend[2*i-4])
        plt.plot(range(epochs), test_acc, label=legend[2*i-3])

    if i == 1:
        plt.xlabel('Epochs')
        plt.ylabel('Accuracy(%)')
        plt.title("Result comparison(ResNet50)")
        plt.legend(loc='best')
        plt.savefig("Result_ResNet50.png")
    if i == 3:
        plt.xlabel('Epochs')
        plt.ylabel('Accuracy(%)')
        plt.title("Result comparison(ResNet50)")
        plt.legend(loc='best')
        plt.savefig("Result_ResNet50.png")
    #plt.show()

# save the model weight 
for i, w in enumerate(model_weight):
    torch.save(w, '{}.pkl'.format(i))

'''
